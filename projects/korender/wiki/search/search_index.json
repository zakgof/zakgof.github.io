{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Korender Korender is a Kotlin Multiplatform 3D graphics rendering engine based on OpenGL / OpenGL ES / WebGL. Latest version: 0.5.1 Github: https://github.com/zakgof/korender License: Apache-2.0 Web demo: https://zakgof.github.io/projects/korender/wasm Supported platforms Platform 3D API Desktop (Windows/Linux) OpenGL 3.3 Android OpenGL ES 3 Web WebGL 2 There is a partial support for MacOS, however note that OpenGL is officially deprecated starting MacOS 10.14 Mojave.","title":"Home"},{"location":"#korender","text":"Korender is a Kotlin Multiplatform 3D graphics rendering engine based on OpenGL / OpenGL ES / WebGL. Latest version: 0.5.1 Github: https://github.com/zakgof/korender License: Apache-2.0 Web demo: https://zakgof.github.io/projects/korender/wasm","title":"Korender"},{"location":"#supported-platforms","text":"Platform 3D API Desktop (Windows/Linux) OpenGL 3.3 Android OpenGL ES 3 Web WebGL 2 There is a partial support for MacOS, however note that OpenGL is officially deprecated starting MacOS 10.14 Mojave.","title":"Supported platforms"},{"location":"assets/","text":"Asset storage Korender uses Kotlin Multiplatform resources for storing assets, such as 3d model files and textures. To let Korender access your assets, provide appResourceLoader as a Korender composable function's arguments. @Composable fun App() = Korender(appResourceLoader = { Res.readBytes(it) }) { // ... Frame { Renderable( base(colorTexture = texture(\"texture/asphalt.jpg\")), In the above example, the texture asset is located in the file commonMain/composeResources/files/texture/asphalt.jpg Korender also includes some bundled resources. To access them, start the path with an exclamation mark: !font/anta.ttf Asset loading and unloading Korender loads an asset as soon as it's declared in a rendering frame. Asset unloading is managed by retention policy. The default policy is to automatically unload a resource after 10 seconds of not being used. Retention policy can be overridden by setting the retentionPolicy var in the Korender context: @Composable Korender(appResourceLoader = { Res.readBytes(it) }) { retentionPolicy = keepForever() Available retention policies: immediatelyFree() - unload a resource immediately after it's not used in a frame. keepForever() - do not unload a resource, keep it forever. time(seconds: Float) - unload a resource after specified number of seconds of not being used. untilGeneration(generation: Int) - use generation-based retention: unload all unused resources which generation is less than the specified value; asset generation is specified by the value of the variable retentionGeneration at the moment of asset loading.","title":"Asset management"},{"location":"assets/#asset-storage","text":"Korender uses Kotlin Multiplatform resources for storing assets, such as 3d model files and textures. To let Korender access your assets, provide appResourceLoader as a Korender composable function's arguments. @Composable fun App() = Korender(appResourceLoader = { Res.readBytes(it) }) { // ... Frame { Renderable( base(colorTexture = texture(\"texture/asphalt.jpg\")), In the above example, the texture asset is located in the file commonMain/composeResources/files/texture/asphalt.jpg Korender also includes some bundled resources. To access them, start the path with an exclamation mark: !font/anta.ttf","title":"Asset storage"},{"location":"assets/#asset-loading-and-unloading","text":"Korender loads an asset as soon as it's declared in a rendering frame. Asset unloading is managed by retention policy. The default policy is to automatically unload a resource after 10 seconds of not being used. Retention policy can be overridden by setting the retentionPolicy var in the Korender context: @Composable Korender(appResourceLoader = { Res.readBytes(it) }) { retentionPolicy = keepForever()","title":"Asset loading and unloading"},{"location":"assets/#available-retention-policies","text":"immediatelyFree() - unload a resource immediately after it's not used in a frame. keepForever() - do not unload a resource, keep it forever. time(seconds: Float) - unload a resource after specified number of seconds of not being used. untilGeneration(generation: Int) - use generation-based retention: unload all unused resources which generation is less than the specified value; asset generation is specified by the value of the variable retentionGeneration at the moment of asset loading.","title":"Available retention policies:"},{"location":"billboards/","text":"Billboards A billboard or impostor is a flat 2D object (usually a textured quad) that always faces the camera, no matter where the camera moves. It's a common trick used to represent complex visuals with simple geometry. To render a billboard, add the Billboard functional declaration to your Frame context. Additionally, apply the billboard material to fine-tune: Billboard ( base(colorTexture = texture(\"textures/sprite.png\")), billboard( position = Vec3(3f, 5f, 7f), scale = Vec2(2f, 2f), rotation = 0.3f ), transparent = true ) billboard materials supports the following parameters: Uniform name Type Default value Description position Vec3 (0, 0, 0) World position of billboard's center scale Vec2 (1, 1) Billboard's size (horizontal/vertical) rotation Float 0.0f Rotation (in radians)","title":"Billboards"},{"location":"billboards/#billboards","text":"A billboard or impostor is a flat 2D object (usually a textured quad) that always faces the camera, no matter where the camera moves. It's a common trick used to represent complex visuals with simple geometry. To render a billboard, add the Billboard functional declaration to your Frame context. Additionally, apply the billboard material to fine-tune: Billboard ( base(colorTexture = texture(\"textures/sprite.png\")), billboard( position = Vec3(3f, 5f, 7f), scale = Vec2(2f, 2f), rotation = 0.3f ), transparent = true ) billboard materials supports the following parameters: Uniform name Type Default value Description position Vec3 (0, 0, 0) World position of billboard's center scale Vec2 (1, 1) Billboard's size (horizontal/vertical) rotation Float 0.0f Rotation (in radians)","title":"Billboards"},{"location":"context/","text":"Korender and Frame contexts To insert Korender rendering viewport into your Compose Multiplatform UI, call the Korender function from the parent @Composable function: @Composable fun App() { Column { Text(\"Korender Viewport below !!!\") Korender { } } } Add initialization code into Korender context, per-frame code and renderable objects into Frame context: Korender { // Code here will run once on Korender viewport initialization Frame { // Code here will run on every frame // Place your renderable declaration functions here } }","title":"Contexts"},{"location":"context/#korender-and-frame-contexts","text":"To insert Korender rendering viewport into your Compose Multiplatform UI, call the Korender function from the parent @Composable function: @Composable fun App() { Column { Text(\"Korender Viewport below !!!\") Korender { } } } Add initialization code into Korender context, per-frame code and renderable objects into Frame context: Korender { // Code here will run once on Korender viewport initialization Frame { // Code here will run on every frame // Place your renderable declaration functions here } }","title":"Korender and Frame contexts"},{"location":"custom/","text":"Custom shaders","title":"Custom shaders"},{"location":"custom/#custom-shaders","text":"","title":"Custom shaders"},{"location":"deferred/","text":"Deferred rendering pipeline Korender support deferred rendering pipeline as an experimental feature. Deferred rendering is a technique where geometry and material data are rendered first into multiple textures called the G-buffer. Lighting is then calculated in a separate pass using this stored data, allowing efficient handling of many dynamic lights. This approach enhances performance in complex scenes and enables various screen-space effects. To switch to deferred rendering, add the following declaration to the Frame context: Frame { DeferredShading() Deferred rendering pipeline supports the following effects: Shading material modifiers Additional material modifiers applied during the shading pass ibl Image-based lighting - environment mapping. In forward rendering pipeline IBL can be applied per-object, in deferred shading it's applied globally in screen space via shading material modifier: Frame { val cubeMap = ... DeferredShading { Shading(ibl(cubeMap)) } Post-shading effects Screen-space effects applied to the frame after the shading pass ssr Screen-space reflections - applied according to the objects' surface properties (metallic/roughness) Frame { val cubeMap = ... DeferredShading { PostShading( ssr( width = width / 4, height = height / 4, fxaa = true, maxRayTravel = 12f, linearSteps = 120, binarySteps = 4, envTexture = cubeMap ) ) } bloom Screen-space bloom (glow) effect Frame { val cubeMap = ... DeferredShading { PostShading( bloom( width = width / 2, height = height / 2 ) ) } Decals Frame { val cubeMap = ... DeferredShading { Decal( base( colorTexture = texture(\"texture/decal.png\"), metallicFactor = 0.2f ), position = pos, look = look, up = up, size = 1.6f ) }","title":"Deferred renderer"},{"location":"deferred/#deferred-rendering-pipeline","text":"Korender support deferred rendering pipeline as an experimental feature. Deferred rendering is a technique where geometry and material data are rendered first into multiple textures called the G-buffer. Lighting is then calculated in a separate pass using this stored data, allowing efficient handling of many dynamic lights. This approach enhances performance in complex scenes and enables various screen-space effects. To switch to deferred rendering, add the following declaration to the Frame context: Frame { DeferredShading() Deferred rendering pipeline supports the following effects:","title":"Deferred rendering pipeline"},{"location":"deferred/#shading-material-modifiers","text":"Additional material modifiers applied during the shading pass","title":"Shading material modifiers"},{"location":"deferred/#ibl","text":"Image-based lighting - environment mapping. In forward rendering pipeline IBL can be applied per-object, in deferred shading it's applied globally in screen space via shading material modifier: Frame { val cubeMap = ... DeferredShading { Shading(ibl(cubeMap)) }","title":"ibl"},{"location":"deferred/#post-shading-effects","text":"Screen-space effects applied to the frame after the shading pass","title":"Post-shading effects"},{"location":"deferred/#ssr","text":"Screen-space reflections - applied according to the objects' surface properties (metallic/roughness) Frame { val cubeMap = ... DeferredShading { PostShading( ssr( width = width / 4, height = height / 4, fxaa = true, maxRayTravel = 12f, linearSteps = 120, binarySteps = 4, envTexture = cubeMap ) ) }","title":"ssr"},{"location":"deferred/#bloom","text":"Screen-space bloom (glow) effect Frame { val cubeMap = ... DeferredShading { PostShading( bloom( width = width / 2, height = height / 2 ) ) }","title":"bloom"},{"location":"deferred/#decals","text":"Frame { val cubeMap = ... DeferredShading { Decal( base( colorTexture = texture(\"texture/decal.png\"), metallicFactor = 0.2f ), position = pos, look = look, up = up, size = 1.6f ) }","title":"Decals"},{"location":"effects/","text":"Effects Korender includes a set of predefined effect shaders, accessible through special material modifiers. Each effect may expose adjustable parameters, which can be configured using effect-specific uniforms. Fire Fire effect implements animated flames. Normally, it's used on a Billboard with transparency enabled: Billboard( billboard(scale = Vec2(2f, 10f)), fire(strength = 4f), transparent = true ) Fire effect parameters: Uniform name Type Default value Description strength Float 3.0f Controls how rippled the flame appears, 1-5 Fireball Fireball is a spherical fire-like effect that can be used for rendering explosions. Normally, it's used on a Billboard with transparency enabled: Billboard( billboard(scale = Vec2(radius * phase, radius * phase)), fireball(power = phase), transparent = true ) Fireball effect parameters: Uniform name Type Default value Description power Float 0.5f Controls the fireball expansion: 0.0 for explosion initiation moment, 1.0 for the fully exploded fireball. Animate 0.0 to 1.0 for explosion effect Smoke Single spherical smoke particle effect. Normally, it's used on a batched Billboard with transparency enabled: Smoke effect parameters: Uniform name Type Default value Description density Float 0.5f Smoke density, 0-1 seed Float 0.0f Randomness seed - provide unique values for uniquely looking smoke particles 0-1 Water Wavy water surface with sky reflections. Water is implemented as a post-process filter: Frame{ ... // Render the scene PostProcess(water(waveScale = 0.05f), fastCloudSky()) } Water parameters: Uniform name Type Default value Description waterColor ColorRGB ColorRGB(0x00182A) Water own color transparency Float 0.1f Water transparency ratio waveScale Float 0.04f Waves scale ratio Additionally, add any sky material modifier to provide sky reflections from the water","title":"Effects"},{"location":"effects/#effects","text":"Korender includes a set of predefined effect shaders, accessible through special material modifiers. Each effect may expose adjustable parameters, which can be configured using effect-specific uniforms.","title":"Effects"},{"location":"effects/#fire","text":"Fire effect implements animated flames. Normally, it's used on a Billboard with transparency enabled: Billboard( billboard(scale = Vec2(2f, 10f)), fire(strength = 4f), transparent = true ) Fire effect parameters: Uniform name Type Default value Description strength Float 3.0f Controls how rippled the flame appears, 1-5","title":"Fire"},{"location":"effects/#fireball","text":"Fireball is a spherical fire-like effect that can be used for rendering explosions. Normally, it's used on a Billboard with transparency enabled: Billboard( billboard(scale = Vec2(radius * phase, radius * phase)), fireball(power = phase), transparent = true ) Fireball effect parameters: Uniform name Type Default value Description power Float 0.5f Controls the fireball expansion: 0.0 for explosion initiation moment, 1.0 for the fully exploded fireball. Animate 0.0 to 1.0 for explosion effect","title":"Fireball"},{"location":"effects/#smoke","text":"Single spherical smoke particle effect. Normally, it's used on a batched Billboard with transparency enabled: Smoke effect parameters: Uniform name Type Default value Description density Float 0.5f Smoke density, 0-1 seed Float 0.0f Randomness seed - provide unique values for uniquely looking smoke particles 0-1","title":"Smoke"},{"location":"effects/#water","text":"Wavy water surface with sky reflections. Water is implemented as a post-process filter: Frame{ ... // Render the scene PostProcess(water(waveScale = 0.05f), fastCloudSky()) } Water parameters: Uniform name Type Default value Description waterColor ColorRGB ColorRGB(0x00182A) Water own color transparency Float 0.1f Water transparency ratio waveScale Float 0.04f Waves scale ratio Additionally, add any sky material modifier to provide sky reflections from the water","title":"Water"},{"location":"env/","text":"Environment mapping Korender supports environment mapping (via cube maps). When enabled, rendered objects incorporate distant lighting from the environment map, following Korender\u2019s physically-based rendering (PBR) model for realistic illumination. Cube map creation There a several ways to create a cube map: from 6 textures images: Frame { val cubeMap = cubeTexture(\"env\", mapOf( NX to \"textures/env-nx.jpg\", NY to \"textures/env-ny.jpg\", NZ to \"textures/env-nz.jpg\", PX to \"textures/env-px.jpg\", PY to \"textures/env-py.jpg\", PZ to \"textures/env-pz.jpg\" )) capture env probe from a scene: Frame { CaptureEnv(\"probe1\", 1024) { // Render capture scene here } val cubeMap = cubeTextureProbe(\"probe1\") Environment rendering To render an object with environment mapping, add the ibl material modifier to a Renderable declaration: Frame { val cubeMap = ... Renderable( base(...), ibl(cubeMap), It's also possible to use a sky material modifier as the ibl source: Frame { Renderable( base(...), ibl(fastCloudSky()),","title":"Environment mapping"},{"location":"env/#environment-mapping","text":"Korender supports environment mapping (via cube maps). When enabled, rendered objects incorporate distant lighting from the environment map, following Korender\u2019s physically-based rendering (PBR) model for realistic illumination.","title":"Environment mapping"},{"location":"env/#cube-map-creation","text":"There a several ways to create a cube map: from 6 textures images: Frame { val cubeMap = cubeTexture(\"env\", mapOf( NX to \"textures/env-nx.jpg\", NY to \"textures/env-ny.jpg\", NZ to \"textures/env-nz.jpg\", PX to \"textures/env-px.jpg\", PY to \"textures/env-py.jpg\", PZ to \"textures/env-pz.jpg\" )) capture env probe from a scene: Frame { CaptureEnv(\"probe1\", 1024) { // Render capture scene here } val cubeMap = cubeTextureProbe(\"probe1\")","title":"Cube map creation"},{"location":"env/#environment-rendering","text":"To render an object with environment mapping, add the ibl material modifier to a Renderable declaration: Frame { val cubeMap = ... Renderable( base(...), ibl(cubeMap), It's also possible to use a sky material modifier as the ibl source: Frame { Renderable( base(...), ibl(fastCloudSky()),","title":"Environment rendering"},{"location":"filters/","text":"Post-processing filters Korender supports post-processing effects that can be applied to the rendered scene. The post-processing pipeline operates as follows: The scene is first rendered to a framebuffer, capturing both color and depth as target textures. Each post-processing effect renders a full-screen quad using a dedicated shader, utilizing color and depth data from the original scene or the output of the previous effect. The final post-processing effect renders directly to the screen. To define a post-processing effect in your frame, use the PostProcess function with one or more material modifiers that specify the effect\u2019s shader. Frame { PostProcess(blurHorz(radius = 3.0f)) PostProcess(blurVert(radius = 3.0f)) Korender includes the following built-in post-processing material modifiers: Post-process filter Description blurHorz Horizontal separable blur pass blurVert Vertical separable blur pass adjust Adjust brightness, contract and saturation water Water effect fog Fog fxaa FXAA anti-aliasing filter","title":"Post-process filters"},{"location":"filters/#post-processing-filters","text":"Korender supports post-processing effects that can be applied to the rendered scene. The post-processing pipeline operates as follows: The scene is first rendered to a framebuffer, capturing both color and depth as target textures. Each post-processing effect renders a full-screen quad using a dedicated shader, utilizing color and depth data from the original scene or the output of the previous effect. The final post-processing effect renders directly to the screen. To define a post-processing effect in your frame, use the PostProcess function with one or more material modifiers that specify the effect\u2019s shader. Frame { PostProcess(blurHorz(radius = 3.0f)) PostProcess(blurVert(radius = 3.0f)) Korender includes the following built-in post-processing material modifiers: Post-process filter Description blurHorz Horizontal separable blur pass blurVert Vertical separable blur pass adjust Adjust brightness, contract and saturation water Water effect fog Fog fxaa FXAA anti-aliasing filter","title":"Post-processing filters"},{"location":"gui/","text":"GUI Korender supports on-screen rendering of texts and images. They can react to touch events (mouse events on the desktop), so it's possible to create basic widgets. Containers, Elements, and Fillers Elements can be positioned on the rendering viewport using containers - stacks, columns, and rows - and fillers. A filler consumes the rest of the available horizontal space in a row, or vertical space in a column. If multiple fillers appear in a container, they share the available space equally. Frame { Gui { Row { Text(text = \"LEFT TOP\", id = \"lt\", fontResource = \"/ubuntu.ttf\", height = 30, color = ColorRBGA(0xFFFF8888)) Filler Text(text = \"RIGHT TOP\", id = \"rt\", fontResource = \"/ubuntu.ttf\", height = 30, color = ColorRBGA(0xFFFF8888)) } Filler Row { Filler Image(imageResource = \"/bottom.png\", width = 100, height = 100) Filler } } } In the above example, the text \"LEFT TOP\" appears in the left top corner, and the text \"RIGHT TOP\" appears in the right top corner; at the bottom of the screen, the image \"/bottom.png\" from resources is rendered, centered horizontally. Element parameters Image: imageResource : image file path width : width in pixels height : height in pixels onTouch : touch event handler Text: text : string to display (ASCII only) id : object used for identification of the element in the tree, must be unique fontResource : classpath of the ttf file color : text color onTouch : touch event handler Touch handlers Touch handlers allow you to react to touch events occurring within the widget's screen rectangle. Touch event contains event type ( Up , Down or Move ) and event coordinates on screen. To handle click events, use the onClick helper: Image( .... onTouch = { onClick(it) { // Handle click here } } )","title":"GUI"},{"location":"gui/#gui","text":"Korender supports on-screen rendering of texts and images. They can react to touch events (mouse events on the desktop), so it's possible to create basic widgets.","title":"GUI"},{"location":"gui/#containers-elements-and-fillers","text":"Elements can be positioned on the rendering viewport using containers - stacks, columns, and rows - and fillers. A filler consumes the rest of the available horizontal space in a row, or vertical space in a column. If multiple fillers appear in a container, they share the available space equally. Frame { Gui { Row { Text(text = \"LEFT TOP\", id = \"lt\", fontResource = \"/ubuntu.ttf\", height = 30, color = ColorRBGA(0xFFFF8888)) Filler Text(text = \"RIGHT TOP\", id = \"rt\", fontResource = \"/ubuntu.ttf\", height = 30, color = ColorRBGA(0xFFFF8888)) } Filler Row { Filler Image(imageResource = \"/bottom.png\", width = 100, height = 100) Filler } } } In the above example, the text \"LEFT TOP\" appears in the left top corner, and the text \"RIGHT TOP\" appears in the right top corner; at the bottom of the screen, the image \"/bottom.png\" from resources is rendered, centered horizontally.","title":"Containers, Elements, and Fillers"},{"location":"gui/#element-parameters","text":"Image: imageResource : image file path width : width in pixels height : height in pixels onTouch : touch event handler Text: text : string to display (ASCII only) id : object used for identification of the element in the tree, must be unique fontResource : classpath of the ttf file color : text color onTouch : touch event handler","title":"Element parameters"},{"location":"gui/#touch-handlers","text":"Touch handlers allow you to react to touch events occurring within the widget's screen rectangle. Touch event contains event type ( Up , Down or Move ) and event coordinates on screen. To handle click events, use the onClick helper: Image( .... onTouch = { onClick(it) { // Handle click here } } )","title":"Touch handlers"},{"location":"instancing/","text":"Instancing To improve rendering performance, Korender supports Renderable and Billboard instancing (batching) - a technique when multiple objects are rendered within one call from a single GPU buffer. Instanced Renderables To render multiple Renderables in a batch, add an instancing parameter when declaring a Renderable in a Frame context. Set the required number of Instance s with appropriate transforms: Frame { Renderable( base(color = Red), mesh = cube(0.3f), instancing = instancing( id = \"cubes\", count = 3, dynamic = true ) { Instance.translate(1.x) Instance.translate(2.x) Instance.translate(3.x) } ) } Assure that the number of instances does not exceed the declared count used to initialize the buffers. If the instances never change, set the dynamic flag to false - this will improve the performance by reading the instances and passing them to the GPU only once. instancing requires a unique id for mesh identification. Instanced Billboards Similarly, billboards can be instanced too: Billboard( base(colorTexture = texture(\"texture/splat.png\")), transparent = true, instancing = billboardInstancing( id = \"particles\", count = 3, dynamic = false ) { Instance(pos = 1.x, scale = Vec2(2f, 2f)) Instance(pos = 2.x, scale = Vec2(3f, 2f)) Instance(pos = 3.x, scale = Vec2(2f, 3f)) } ) For each Instance , define pos , scale , and rotation of the billboard. The transparent flag should be enabled if the billboards have transparency to sort the instances back to front.","title":"Instancing"},{"location":"instancing/#instancing","text":"To improve rendering performance, Korender supports Renderable and Billboard instancing (batching) - a technique when multiple objects are rendered within one call from a single GPU buffer.","title":"Instancing"},{"location":"instancing/#instanced-renderables","text":"To render multiple Renderables in a batch, add an instancing parameter when declaring a Renderable in a Frame context. Set the required number of Instance s with appropriate transforms: Frame { Renderable( base(color = Red), mesh = cube(0.3f), instancing = instancing( id = \"cubes\", count = 3, dynamic = true ) { Instance.translate(1.x) Instance.translate(2.x) Instance.translate(3.x) } ) } Assure that the number of instances does not exceed the declared count used to initialize the buffers. If the instances never change, set the dynamic flag to false - this will improve the performance by reading the instances and passing them to the GPU only once. instancing requires a unique id for mesh identification.","title":"Instanced Renderables"},{"location":"instancing/#instanced-billboards","text":"Similarly, billboards can be instanced too: Billboard( base(colorTexture = texture(\"texture/splat.png\")), transparent = true, instancing = billboardInstancing( id = \"particles\", count = 3, dynamic = false ) { Instance(pos = 1.x, scale = Vec2(2f, 2f)) Instance(pos = 2.x, scale = Vec2(3f, 2f)) Instance(pos = 3.x, scale = Vec2(2f, 3f)) } ) For each Instance , define pos , scale , and rotation of the billboard. The transparent flag should be enabled if the billboards have transparency to sort the instances back to front.","title":"Instanced Billboards"},{"location":"light/","text":"Lights Korender supports 3 types of light sources: ambient light directional lights point lights All types of lights can be declared dynamically in the Frame context: Frame { AmbientLight(white(0.25f)) PointLight(Vec3(100f, 20f, 100f), ColorRGB.Green) DirectionalLight(Vec3(1f, -1f, 2f), white(1.0f)) Shadows Shadows are supported for directional lights. Korender supports multiple cascades of shadow maps with automatic blending of maps within overlapping cascades. The supported mapping techniques are: Hard shadows - straightforward shadow mapping with no shadow edge anti-aliasing. Software PCF shadows - soft shadows with blurring filter using Vogel disk sampling Hardware PCF shadows - percentage-close filtering on GPU provided by OpenGL implementation VSM - variance shadow mapping Frame { DirectionalLight(Vec3(1f, -1f, 0.3f), white(5.0f)) { Cascade(mapSize = 1024, near = 4f, far = 12f, algorithm = softwarePcf(samples = 16, blurRadius = 0.01f)) Cascade(mapSize = 1024, near = 10f, far = 30f, algorithm = vsm(blurRadius = 0.01f)) Cascade(mapSize = 1024, near = 25f, far = 100f, algorithm = vsm(blurRadius = 0.02f)) }","title":"Lights and shadows"},{"location":"light/#lights","text":"Korender supports 3 types of light sources: ambient light directional lights point lights All types of lights can be declared dynamically in the Frame context: Frame { AmbientLight(white(0.25f)) PointLight(Vec3(100f, 20f, 100f), ColorRGB.Green) DirectionalLight(Vec3(1f, -1f, 2f), white(1.0f))","title":"Lights"},{"location":"light/#shadows","text":"Shadows are supported for directional lights. Korender supports multiple cascades of shadow maps with automatic blending of maps within overlapping cascades. The supported mapping techniques are: Hard shadows - straightforward shadow mapping with no shadow edge anti-aliasing. Software PCF shadows - soft shadows with blurring filter using Vogel disk sampling Hardware PCF shadows - percentage-close filtering on GPU provided by OpenGL implementation VSM - variance shadow mapping Frame { DirectionalLight(Vec3(1f, -1f, 0.3f), white(5.0f)) { Cascade(mapSize = 1024, near = 4f, far = 12f, algorithm = softwarePcf(samples = 16, blurRadius = 0.01f)) Cascade(mapSize = 1024, near = 10f, far = 30f, algorithm = vsm(blurRadius = 0.01f)) Cascade(mapSize = 1024, near = 25f, far = 100f, algorithm = vsm(blurRadius = 0.02f)) }","title":"Shadows"},{"location":"materials/","text":"Materials and material modifiers Internally, a material definition in Korender consists of: shader - a small program running on the GPU to render objects, which is defined by vertex shader - GPU code in GLSL language to process mesh vertices fragment shader - GPU code in GLSL language to process rendered pixels (fragments) defs - a set of flags that control shader options plugins - customized chunks of code to be injected into shaders uniforms - key-value pairs representing shaders' parameters Each of the above material components can be modified by a MaterialModifier . Using custom shaders or shader plugins is an advanced topic, however, predefined materials should be sufficient for most use cases. Base material Korender comes with a predefined base material supporting a decent lighting set and texturing options. Additionally, several modifiers are available to enable additional features on top of the base material: base( color = ColorRGBA(0x203040FF), colorTexture = texture(\"textures/texture.png\"), metallicFactor = 0.5f, roughnessFactor = 0.3f ), triplanar( scale = 0.5f ) base modifier Basic rendering with texturing and PBR lighting model Uniform name Type Default value Description color ColorRGBA ColorRBGA.White Base surface color (albedo) colorTexture TextureDeclaration - Base surface texture (albedo), texel values are multiplied by color metallicFactor Float 0.1f PBR metallic factor: from 0.0 (non-metal) to 1.0 (metal). Metals reflect more light and do not have a diffuse color \u2014 their color comes from specular reflections. Non-metals reflect less light and have a diffuse base color. roughnessFactor Float 0.5f PBR roughness factor: from 0.0 (smooth) to 1.0 (rough). Affects how light scatters off the surface. Low roughness = sharp, mirror-like reflections. High roughness = diffuse, blurry reflections. triplanar modifier Enables triplanar texturing. Instead of using UV coordinates, triplanar texturing projects the texture onto the surface from three directions: X-axis (side), Y-axis (top), Z-axis (front). The results are blended together based on the surface normal to avoid visible seams. Uniform name Type Default value Description scale Float 1.0f Controls how large or small the texture appears when projected onto the object. High scale value: texture appears more frequently repeated (smaller features). Low scale value: texture appears stretched or zoomed in (larger features). scale = 1.0 \u2192 Texture covers 1 unit of world space. normalTexture modifier Enables normal texturing. A normal texture is a special kind of image used to simulate fine surface detail, such as bumps, wrinkles, or grooves, without increasing the polygon count of a model. Uniform name Type Default value Description normalTexture TextureDeclaration - Normal texture emission modifier Enables material emission factor/color. Emission refers to the ability of a surface to emit light, as if it's glowing on its own without needing any external light source. Emitted light is added to diffuse/directional light reflected from the surface. Uniform name Type Default value Description factor ColorRGB - Emission factor/color metallicRoughnessTexture modifier Enables metallic-roughness texture - a packed texture used in PBR to control how a material reflects light. It stores two properties: metallic and roughness in respectively, B and G channels of the texture. Uniform name Type Default value Description texture TextureDeclaration - Metallic-roughness texture","title":"Materials"},{"location":"materials/#materials-and-material-modifiers","text":"Internally, a material definition in Korender consists of: shader - a small program running on the GPU to render objects, which is defined by vertex shader - GPU code in GLSL language to process mesh vertices fragment shader - GPU code in GLSL language to process rendered pixels (fragments) defs - a set of flags that control shader options plugins - customized chunks of code to be injected into shaders uniforms - key-value pairs representing shaders' parameters Each of the above material components can be modified by a MaterialModifier . Using custom shaders or shader plugins is an advanced topic, however, predefined materials should be sufficient for most use cases.","title":"Materials and material modifiers"},{"location":"materials/#base-material","text":"Korender comes with a predefined base material supporting a decent lighting set and texturing options. Additionally, several modifiers are available to enable additional features on top of the base material: base( color = ColorRGBA(0x203040FF), colorTexture = texture(\"textures/texture.png\"), metallicFactor = 0.5f, roughnessFactor = 0.3f ), triplanar( scale = 0.5f )","title":"Base material"},{"location":"materials/#base-modifier","text":"Basic rendering with texturing and PBR lighting model Uniform name Type Default value Description color ColorRGBA ColorRBGA.White Base surface color (albedo) colorTexture TextureDeclaration - Base surface texture (albedo), texel values are multiplied by color metallicFactor Float 0.1f PBR metallic factor: from 0.0 (non-metal) to 1.0 (metal). Metals reflect more light and do not have a diffuse color \u2014 their color comes from specular reflections. Non-metals reflect less light and have a diffuse base color. roughnessFactor Float 0.5f PBR roughness factor: from 0.0 (smooth) to 1.0 (rough). Affects how light scatters off the surface. Low roughness = sharp, mirror-like reflections. High roughness = diffuse, blurry reflections.","title":"base modifier"},{"location":"materials/#triplanar-modifier","text":"Enables triplanar texturing. Instead of using UV coordinates, triplanar texturing projects the texture onto the surface from three directions: X-axis (side), Y-axis (top), Z-axis (front). The results are blended together based on the surface normal to avoid visible seams. Uniform name Type Default value Description scale Float 1.0f Controls how large or small the texture appears when projected onto the object. High scale value: texture appears more frequently repeated (smaller features). Low scale value: texture appears stretched or zoomed in (larger features). scale = 1.0 \u2192 Texture covers 1 unit of world space.","title":"triplanar modifier"},{"location":"materials/#normaltexture-modifier","text":"Enables normal texturing. A normal texture is a special kind of image used to simulate fine surface detail, such as bumps, wrinkles, or grooves, without increasing the polygon count of a model. Uniform name Type Default value Description normalTexture TextureDeclaration - Normal texture","title":"normalTexture modifier"},{"location":"materials/#emission-modifier","text":"Enables material emission factor/color. Emission refers to the ability of a surface to emit light, as if it's glowing on its own without needing any external light source. Emitted light is added to diffuse/directional light reflected from the surface. Uniform name Type Default value Description factor ColorRGB - Emission factor/color","title":"emission modifier"},{"location":"materials/#metallicroughnesstexture-modifier","text":"Enables metallic-roughness texture - a packed texture used in PBR to control how a material reflects light. It stores two properties: metallic and roughness in respectively, B and G channels of the texture. Uniform name Type Default value Description texture TextureDeclaration - Metallic-roughness texture","title":"metallicRoughnessTexture modifier"},{"location":"meshes/","text":"Meshes There are predefined helper functions for common shapes: quad(1.0f, 2.0f) - quad in xy plane with half-side 1.0 along x and 2.0 along y axis cube(0.5f) - cube with half-side 0.5 sphere(1.0f) - sphere with radius 1.0 disk(1.0f) - disk with radius 1.0 coneTop(1.0f, 2.0f) - conical surface with height 1.0 and radius 1.0 cylinderSide(1.0f, 2.0f) - cylindrical surface with height 1.0 and radius 1.0 obj(\"models/file.obj\") - loads a mesh from a Wavefront .obj file models/file.obj It's also possible to generate custom meshes via the customMesh helper function: customMesh(\"road\", 4, 6) { pos(-0.5f, 0f, 0f).normal(1.y).tex(0f, 0f) pos(-0.5f, 0f, 32f).normal(1.y).tex(0f, 32f) pos(0.5f, 0f, 32f).normal(1.y).tex(1f, 32f) pos(0.5f, 0f, 0f).normal(1.y).tex(1f, 0f) index(0, 1, 2, 0, 2, 3) } Note that if dynamic attribute is set to true , the initializer block of the mesh if called every frame and mesh data is updated in GPU dynamically.","title":"Meshes"},{"location":"meshes/#meshes","text":"There are predefined helper functions for common shapes: quad(1.0f, 2.0f) - quad in xy plane with half-side 1.0 along x and 2.0 along y axis cube(0.5f) - cube with half-side 0.5 sphere(1.0f) - sphere with radius 1.0 disk(1.0f) - disk with radius 1.0 coneTop(1.0f, 2.0f) - conical surface with height 1.0 and radius 1.0 cylinderSide(1.0f, 2.0f) - cylindrical surface with height 1.0 and radius 1.0 obj(\"models/file.obj\") - loads a mesh from a Wavefront .obj file models/file.obj It's also possible to generate custom meshes via the customMesh helper function: customMesh(\"road\", 4, 6) { pos(-0.5f, 0f, 0f).normal(1.y).tex(0f, 0f) pos(-0.5f, 0f, 32f).normal(1.y).tex(0f, 32f) pos(0.5f, 0f, 32f).normal(1.y).tex(1f, 32f) pos(0.5f, 0f, 0f).normal(1.y).tex(1f, 0f) index(0, 1, 2, 0, 2, 3) } Note that if dynamic attribute is set to true , the initializer block of the mesh if called every frame and mesh data is updated in GPU dynamically.","title":"Meshes"},{"location":"offscreen/","text":"Offscreen rendering and probes Offscreen Instead of rendering to screen, Korender allows to render a scene to a texture or to a cube map. This can be done from Korender context (not from Frame context) Render to texture Render to cube map Capturing probes Capturing texture probes Capturing environment probes","title":"Offscreen rendering and probes"},{"location":"offscreen/#offscreen-rendering-and-probes","text":"","title":"Offscreen rendering and probes"},{"location":"offscreen/#offscreen","text":"Instead of rendering to screen, Korender allows to render a scene to a texture or to a cube map. This can be done from Korender context (not from Frame context)","title":"Offscreen"},{"location":"offscreen/#render-to-texture","text":"","title":"Render to texture"},{"location":"offscreen/#render-to-cube-map","text":"","title":"Render to cube map"},{"location":"offscreen/#capturing-probes","text":"","title":"Capturing probes"},{"location":"offscreen/#capturing-texture-probes","text":"","title":"Capturing texture probes"},{"location":"offscreen/#capturing-environment-probes","text":"","title":"Capturing environment probes"},{"location":"plugins/","text":"Plugins","title":"Plugins"},{"location":"plugins/#plugins","text":"","title":"Plugins"},{"location":"projection/","text":"Projection Korender supports perspective (frustum) and orthographic projections. Set the projection property of Korender context to set the projection transform. The below example takes into account the viewport aspect ratio: Frame { projection = projection(4f * width / height, 4f, 4f, 10000f, ortho()) Default projection is projection(width = 5f * width / height, height = 5f, near = 10f, far = 1000f, frustum()) Additionally, Korender supports logarithmic depth buffer - a depth buffer technique that stores the logarithm of the depth value instead of the linear depth. It is especially useful in rendering large-scale scenes (e.g., planetary terrain, open-world games) where depth precision becomes problematic. Frame { projection = projection(4f * width / height, 4f, 4f, 10000f, log()) Camera Set the camera property of the Korender context to set the camera: Frame { camera = camera(Vec3(-2.0f, 5f, 30f), -1.z, 1.y) Default camera is camera(20.z, -1.z, 1.y)","title":"Projection and camera"},{"location":"projection/#projection","text":"Korender supports perspective (frustum) and orthographic projections. Set the projection property of Korender context to set the projection transform. The below example takes into account the viewport aspect ratio: Frame { projection = projection(4f * width / height, 4f, 4f, 10000f, ortho()) Default projection is projection(width = 5f * width / height, height = 5f, near = 10f, far = 1000f, frustum()) Additionally, Korender supports logarithmic depth buffer - a depth buffer technique that stores the logarithm of the depth value instead of the linear depth. It is especially useful in rendering large-scale scenes (e.g., planetary terrain, open-world games) where depth precision becomes problematic. Frame { projection = projection(4f * width / height, 4f, 4f, 10000f, log())","title":"Projection"},{"location":"projection/#camera","text":"Set the camera property of the Korender context to set the camera: Frame { camera = camera(Vec3(-2.0f, 5f, 30f), -1.z, 1.y) Default camera is camera(20.z, -1.z, 1.y)","title":"Camera"},{"location":"renderables/","text":"Renderables basics To render objects, add their Renderable declarations into the Frame context Frame { Renderable( base(color = ColorRGBA.Red, metallicFactor = 0f, roughnessFactor = 0.2f), mesh = sphere(), transform = translate(-2f, -1f, -5f), transparent = false ) A Renderable declaration has the following parameters: materialModifiers - define the surface material properties of a renderable mesh - defines the geometry of the object. Internally, a mesh is an indexed list of vertices forming triangles transform - model space transformation of the object, such as scaling, rotation, or positioning transparent - flag specifying if the object has any transparency","title":"Renderables"},{"location":"renderables/#renderables-basics","text":"To render objects, add their Renderable declarations into the Frame context Frame { Renderable( base(color = ColorRGBA.Red, metallicFactor = 0f, roughnessFactor = 0.2f), mesh = sphere(), transform = translate(-2f, -1f, -5f), transparent = false ) A Renderable declaration has the following parameters: materialModifiers - define the surface material properties of a renderable mesh - defines the geometry of the object. Internally, a mesh is an indexed list of vertices forming triangles transform - model space transformation of the object, such as scaling, rotation, or positioning transparent - flag specifying if the object has any transparency","title":"Renderables basics"},{"location":"sky/","text":"Sky rendering Korender supports several ways to render sky: Cubemap sky Provide 6 textures to construct a skybox cube map: Frame { Sky(cubeSky(cubeTexture(\"sky\", mapOf( NX to \"textures/skybox-nx.jpg\", NY to \"textures/skybox-ny.jpg\", NZ to \"textures/skybox-nz.jpg\", PX to \"textures/skybox-px.jpg\", PY to \"textures/skybox-py.jpg\", PZ to \"textures/skybox-pz.jpg\" )))) Single-texture sky Supply a single texture that will be projected onto the sky dome, accounting for projection distortion Frame { Sky(textureSky(\"textures/sky.jpg\")) Procedural sky Choose from several predefined parameterized procedural sky presets: Frame { Sky(fastCloudSky(thickness = 12.0f, rippleAmount = 0.4f)) Presets: fastCloudSky Procedural day sky with clouds, supported parameters: Uniform name Type Default value Description density Float 3.0f Cloud density, 1-5 thickness Float 10.0f Cloud thickness, 0-20 scale Float 1.0f Cloud scale, 0.1-10 rippleAmount Float 0.3f Cloud high-frequency ripple amount, 0-1 rippleScale Float 4.0f Cloud ripple frequency multiplier, 1-10 zenithColor Color Color(0x3F6FC3) Sky color at zenith horizonColor Color Color(0xB8CAE9) Sky color at horizon cloudLight Float 1.0f Max lightness of clouds cloudDark Float 0.7f Min lightness of clouds starrySky Procedural night sky with colorful stars: Uniform name Type Default value Description colorness Float 0.8f Star color intensity density Float 20.0f Star density (amount) speed Float 1.0f Star motion speed factor size Float 15.0f Star radius factor","title":"Sky rendering"},{"location":"sky/#sky-rendering","text":"Korender supports several ways to render sky:","title":"Sky rendering"},{"location":"sky/#cubemap-sky","text":"Provide 6 textures to construct a skybox cube map: Frame { Sky(cubeSky(cubeTexture(\"sky\", mapOf( NX to \"textures/skybox-nx.jpg\", NY to \"textures/skybox-ny.jpg\", NZ to \"textures/skybox-nz.jpg\", PX to \"textures/skybox-px.jpg\", PY to \"textures/skybox-py.jpg\", PZ to \"textures/skybox-pz.jpg\" ))))","title":"Cubemap sky"},{"location":"sky/#single-texture-sky","text":"Supply a single texture that will be projected onto the sky dome, accounting for projection distortion Frame { Sky(textureSky(\"textures/sky.jpg\"))","title":"Single-texture sky"},{"location":"sky/#procedural-sky","text":"Choose from several predefined parameterized procedural sky presets: Frame { Sky(fastCloudSky(thickness = 12.0f, rippleAmount = 0.4f))","title":"Procedural sky"},{"location":"sky/#presets","text":"","title":"Presets:"},{"location":"sky/#fastcloudsky","text":"Procedural day sky with clouds, supported parameters: Uniform name Type Default value Description density Float 3.0f Cloud density, 1-5 thickness Float 10.0f Cloud thickness, 0-20 scale Float 1.0f Cloud scale, 0.1-10 rippleAmount Float 0.3f Cloud high-frequency ripple amount, 0-1 rippleScale Float 4.0f Cloud ripple frequency multiplier, 1-10 zenithColor Color Color(0x3F6FC3) Sky color at zenith horizonColor Color Color(0xB8CAE9) Sky color at horizon cloudLight Float 1.0f Max lightness of clouds cloudDark Float 0.7f Min lightness of clouds","title":"fastCloudSky"},{"location":"sky/#starrysky","text":"Procedural night sky with colorful stars: Uniform name Type Default value Description colorness Float 0.8f Star color intensity density Float 20.0f Star density (amount) speed Float 1.0f Star motion speed factor size Float 15.0f Star radius factor","title":"starrySky"}]}