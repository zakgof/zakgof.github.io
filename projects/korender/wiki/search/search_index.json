{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Korender Korender is a Kotlin Multiplatform 3D graphics rendering engine based on OpenGL / OpenGL ES / WebGL. Latest version: 0.5.1 Github: https://github.com/zakgof/korender License: Apache-2.0 Web demo: https://zakgof.github.io/projects/korender/wasm Supported platforms Platform 3D API Desktop (Windows/Linux) OpenGL 3.3 Android OpenGL ES 3 Web WebGL 2 There is a partial support for MacOS, however note that OpenGL is officially deprecated starting MacOS 10.14 Mojave.","title":"Home"},{"location":"#korender","text":"Korender is a Kotlin Multiplatform 3D graphics rendering engine based on OpenGL / OpenGL ES / WebGL. Latest version: 0.5.1 Github: https://github.com/zakgof/korender License: Apache-2.0 Web demo: https://zakgof.github.io/projects/korender/wasm","title":"Korender"},{"location":"#supported-platforms","text":"Platform 3D API Desktop (Windows/Linux) OpenGL 3.3 Android OpenGL ES 3 Web WebGL 2 There is a partial support for MacOS, however note that OpenGL is officially deprecated starting MacOS 10.14 Mojave.","title":"Supported platforms"},{"location":"assets/","text":"Asset storage Korender uses Kotlin Multiplatform resources for storing assets, such as 3d model files and textures. To let Korender access your assets, provide appResourceLoader as a Korender composable function's arguments. @Composable fun App() = Korender(appResourceLoader = { Res.readBytes(it) }) { // ... Frame { Renderable( base(colorTexture = texture(\"texture/asphalt.jpg\")), In the above example, the texture asset is located in the file commonMain/composeResources/files/texture/asphalt.jpg Korender also includes some bundled resources. To access them, start the path with an exclamation mark: !font/anta.ttf Asset loading and unloading Korender loads an asset as soon as it's declared in a rendering frame. Asset unloading is managed by retention policy. The default policy is to automatically unload a resource after 10 seconds of not being used. Retention policy can be overridden by setting the retentionPolicy var in the Korender context: @Composable Korender(appResourceLoader = { Res.readBytes(it) }) { retentionPolicy = keepForever() Available retention policies: immediatelyFree() - unload a resource immediately after it's not used in a frame. keepForever() - do not unload a resource, keep it forever. time(seconds: Float) - unload a resource after specified number of seconds of not being used. untilGeneration(generation: Int) - use generation-based retention: unload all unused resources which generation is less than the specified value; asset generation is specified by the value of the variable retentionGeneration at the moment of asset loading.","title":"Asset management"},{"location":"assets/#asset-storage","text":"Korender uses Kotlin Multiplatform resources for storing assets, such as 3d model files and textures. To let Korender access your assets, provide appResourceLoader as a Korender composable function's arguments. @Composable fun App() = Korender(appResourceLoader = { Res.readBytes(it) }) { // ... Frame { Renderable( base(colorTexture = texture(\"texture/asphalt.jpg\")), In the above example, the texture asset is located in the file commonMain/composeResources/files/texture/asphalt.jpg Korender also includes some bundled resources. To access them, start the path with an exclamation mark: !font/anta.ttf","title":"Asset storage"},{"location":"assets/#asset-loading-and-unloading","text":"Korender loads an asset as soon as it's declared in a rendering frame. Asset unloading is managed by retention policy. The default policy is to automatically unload a resource after 10 seconds of not being used. Retention policy can be overridden by setting the retentionPolicy var in the Korender context: @Composable Korender(appResourceLoader = { Res.readBytes(it) }) { retentionPolicy = keepForever()","title":"Asset loading and unloading"},{"location":"assets/#available-retention-policies","text":"immediatelyFree() - unload a resource immediately after it's not used in a frame. keepForever() - do not unload a resource, keep it forever. time(seconds: Float) - unload a resource after specified number of seconds of not being used. untilGeneration(generation: Int) - use generation-based retention: unload all unused resources which generation is less than the specified value; asset generation is specified by the value of the variable retentionGeneration at the moment of asset loading.","title":"Available retention policies:"},{"location":"context/","text":"Korender and Frame contexts To insert Korender rendering viewport into your Compose Multiplatform UI, call the Korender function from the parent @Composable function: @Composable fun App() { Column { Text(\"Korender Viewport below !!!\") Korender { } } } Add initialization code into Korender context, per-frame code and renderable objects into Frame context: Korender { // Code here will run once on Korender viewport initialization Frame { // Code here will run on every frame // Place your renderable declaration functions here } }","title":"Contexts"},{"location":"context/#korender-and-frame-contexts","text":"To insert Korender rendering viewport into your Compose Multiplatform UI, call the Korender function from the parent @Composable function: @Composable fun App() { Column { Text(\"Korender Viewport below !!!\") Korender { } } } Add initialization code into Korender context, per-frame code and renderable objects into Frame context: Korender { // Code here will run once on Korender viewport initialization Frame { // Code here will run on every frame // Place your renderable declaration functions here } }","title":"Korender and Frame contexts"},{"location":"renderables/","text":"Renderables basics To render objects, add their Renderable declarations into the Frame context Frame { Renderable( base(color = ColorRGBA.Red, metallicFactor = 0f, roughnessFactor = 0.2f), mesh = sphere(), transform = translate(-2f, -1f, -5f), transparent = false ) The function Renderable has the following parameters: - materialModifiers - define the surface material properties of a renderable - mesh - defines the geometry of the object. Internally, a mesh is an indexed list of vertices forming triangles - transform - model space transformation of the object, such as scaling, rotation, or positioning - transparent - flag specifying if the object has any transparency Materials and material modifiers Internally, the material definition in Korender consists of: - shader - a small program running on the GPU to render objects, which is defined by - vertex shader - GPU code in GLSL language to process mesh vertices - fragment shader - GPU code in GLSL language to process rendered pixels (fragments) - defs - a set of flags that control shader options - plugins - customized chunks of code to be injected into shaders - uniforms - key-value pairs representing shaders' parameters Each of the above material components can be modified by a MaterialModifier . Using custom shaders or shader plugins is an advanced topic, however, predefined materials should be sufficient for most use cases. Base material Korender comes with a predefined base material supporting a decent lighting set and texturing options. Additionally, several modifiers are available to enable additional features on top of the base material: base( color = ColorRGBA(0x203040FF), colorTexture = texture(\"textures/texture.png\"), metallicFactor = 0.5f, roughnessFactor = 0.3f ), triplanar( scale = 0.5f ) base modifier Basic rendering with texturing and PBR lighting model Uniform name Type Default value Description color ColorRGBA ColorRBGA.White Base surface color (albedo) colorTexture TextureDeclaration - Base surface texture (albedo), texel values are multiplied by color metallicFactor Float 0.1f PBR metallic factor: from 0.0 (non-metal) to 1.0 (metal). Metals reflect more light and do not have a diffuse color \u2014 their color comes from specular reflections. Non-metals reflect less light and have a diffuse base color. roughnessFactor Float 0.5f PBR roughness factor: from 0.0 (smooth) to 1.0 (rough). Affects how light scatters off the surface. Low roughness = sharp, mirror-like reflections. High roughness = diffuse, blurry reflections. triplanar modifier Enables triplanar texturing. Instead of using UV coordinates, triplanar texturing projects the texture onto the surface from three directions: X-axis (side), Y-axis (top), Z-axis (front). The results are blended together based on the surface normal to avoid visible seams. Uniform name Type Default value Description scale Float 1.0f Controls how large or small the texture appears when projected onto the object. High scale value: texture appears more frequently repeated (smaller features). Low scale value: texture appears stretched or zoomed in (larger features). scale = 1.0 \u2192 Texture covers 1 unit of world space. normalTexture modifier Enables normal texturing. A normal texture is a special kind of image used to simulate fine surface detail, such as bumps, wrinkles, or grooves, without increasing the polygon count of a model. Uniform name Type Default value Description normalTexture TextureDeclaration - Normal texture emission modifier Enables material emission factor/color. Emission refers to the ability of a surface to emit light, as if it's glowing on its own without needing any external light source. Emitted light is added to diffuse/directional light reflected from the surface. Uniform name Type Default value Description factor ColorRGB - Emission factor/color metallicRoughnessTexture modifier Enables metallic-roughness texture - a packed texture used in PBR to control how a material reflects light. It stores two properties: metallic and roughness in respectively, B and G channels of the texture. Uniform name Type Default value Description texture TextureDeclaration - Metallic-roughness texture Meshes There are predefined helper functions for common shapes: Cube: cube(0.5f) Sphere: sphere(1.0f) Screen quad - used for filters: ScreenQuad Height field: heightField(\"id\", 32, 32, 1.0f, heightFunc) Load mesh from obj file (from classpath): obj(\"/model.obj\") It's also possible to generate custom meshes via the customMesh helper function","title":"Renderables"},{"location":"renderables/#renderables-basics","text":"To render objects, add their Renderable declarations into the Frame context Frame { Renderable( base(color = ColorRGBA.Red, metallicFactor = 0f, roughnessFactor = 0.2f), mesh = sphere(), transform = translate(-2f, -1f, -5f), transparent = false ) The function Renderable has the following parameters: - materialModifiers - define the surface material properties of a renderable - mesh - defines the geometry of the object. Internally, a mesh is an indexed list of vertices forming triangles - transform - model space transformation of the object, such as scaling, rotation, or positioning - transparent - flag specifying if the object has any transparency","title":"Renderables basics"},{"location":"renderables/#materials-and-material-modifiers","text":"Internally, the material definition in Korender consists of: - shader - a small program running on the GPU to render objects, which is defined by - vertex shader - GPU code in GLSL language to process mesh vertices - fragment shader - GPU code in GLSL language to process rendered pixels (fragments) - defs - a set of flags that control shader options - plugins - customized chunks of code to be injected into shaders - uniforms - key-value pairs representing shaders' parameters Each of the above material components can be modified by a MaterialModifier . Using custom shaders or shader plugins is an advanced topic, however, predefined materials should be sufficient for most use cases.","title":"Materials and material modifiers"},{"location":"renderables/#base-material","text":"Korender comes with a predefined base material supporting a decent lighting set and texturing options. Additionally, several modifiers are available to enable additional features on top of the base material: base( color = ColorRGBA(0x203040FF), colorTexture = texture(\"textures/texture.png\"), metallicFactor = 0.5f, roughnessFactor = 0.3f ), triplanar( scale = 0.5f )","title":"Base material"},{"location":"renderables/#base-modifier","text":"Basic rendering with texturing and PBR lighting model Uniform name Type Default value Description color ColorRGBA ColorRBGA.White Base surface color (albedo) colorTexture TextureDeclaration - Base surface texture (albedo), texel values are multiplied by color metallicFactor Float 0.1f PBR metallic factor: from 0.0 (non-metal) to 1.0 (metal). Metals reflect more light and do not have a diffuse color \u2014 their color comes from specular reflections. Non-metals reflect less light and have a diffuse base color. roughnessFactor Float 0.5f PBR roughness factor: from 0.0 (smooth) to 1.0 (rough). Affects how light scatters off the surface. Low roughness = sharp, mirror-like reflections. High roughness = diffuse, blurry reflections.","title":"base modifier"},{"location":"renderables/#triplanar-modifier","text":"Enables triplanar texturing. Instead of using UV coordinates, triplanar texturing projects the texture onto the surface from three directions: X-axis (side), Y-axis (top), Z-axis (front). The results are blended together based on the surface normal to avoid visible seams. Uniform name Type Default value Description scale Float 1.0f Controls how large or small the texture appears when projected onto the object. High scale value: texture appears more frequently repeated (smaller features). Low scale value: texture appears stretched or zoomed in (larger features). scale = 1.0 \u2192 Texture covers 1 unit of world space.","title":"triplanar modifier"},{"location":"renderables/#normaltexture-modifier","text":"Enables normal texturing. A normal texture is a special kind of image used to simulate fine surface detail, such as bumps, wrinkles, or grooves, without increasing the polygon count of a model. Uniform name Type Default value Description normalTexture TextureDeclaration - Normal texture","title":"normalTexture modifier"},{"location":"renderables/#emission-modifier","text":"Enables material emission factor/color. Emission refers to the ability of a surface to emit light, as if it's glowing on its own without needing any external light source. Emitted light is added to diffuse/directional light reflected from the surface. Uniform name Type Default value Description factor ColorRGB - Emission factor/color","title":"emission modifier"},{"location":"renderables/#metallicroughnesstexture-modifier","text":"Enables metallic-roughness texture - a packed texture used in PBR to control how a material reflects light. It stores two properties: metallic and roughness in respectively, B and G channels of the texture. Uniform name Type Default value Description texture TextureDeclaration - Metallic-roughness texture","title":"metallicRoughnessTexture modifier"},{"location":"renderables/#meshes","text":"There are predefined helper functions for common shapes: Cube: cube(0.5f) Sphere: sphere(1.0f) Screen quad - used for filters: ScreenQuad Height field: heightField(\"id\", 32, 32, 1.0f, heightFunc) Load mesh from obj file (from classpath): obj(\"/model.obj\") It's also possible to generate custom meshes via the customMesh helper function","title":"Meshes"}]}